
0. Implementing Advanced Model Relationships in Django
mandatory

Objective: Master Django’s ORM capabilities by creating a set of models that demonstrate the use of ForeignKey, ManyToMany, and OneToOne relationships. This task will help you understand how to model complex data relationships in a Django project effectively.
Task Description:

Duplicate the previous project directory Introduction_ to_ Django, rename it to django-models and add a new app named relationship_app where you’ll define models that showcase complex relationships between entities using ForeignKey, ManyToMany, and OneToOne fields.
Steps:

    Create the relationship_app App:
        Within your Django project directory, generate a new app: python manage.py startapp relationship_app.

    Define Complex Models in relationship_app/models.py:
        Author Model:
            name: CharField.
        Book Model:
            title: CharField.
            author: ForeignKey to Author.
        Library Model:
            name: CharField.
            books: ManyToManyField to Book.
        Librarian Model:
            name: CharField.
            library: OneToOneField to Library.

    Apply Database Migrations:
        Run migrations to create your model tables: python manage.py makemigrations relationship_app followed by python manage.py migrate.

    Implement Sample Queries:
        Prepare a Python script query_samples.py in the relationship_app directory. This script should contain the query for each of the following of relationship:
            Query all books by a specific author.
            List all books in a library.
            Retrieve the librarian for a library.

Repo:

    GitHub repository: Alx_DjangoLearnLab
    Directory: django-models
    File: models.py, query_samples.py

1. Django Views and URL Configuration
mandatory

Objective: Develop proficiency in creating both function-based and class-based views in Django, and configuring URL patterns to handle web requests effectively. This task will help you understand different ways to define views and manage URL routing in Django.
Task Description:

In your existing Django project, enhance the relationship_app by adding new views that display information about books and libraries. Implement both function-based and class-based views to handle these displays and configure the URL patterns to route these views correctly.
Steps:

    Implement Function-based View:
        Create a function-based view in relationship_app/views.py that lists all books stored in the database.
        This view should render a simple text list of book titles and their authors.

    Implement Class-based View:
        Create a class-based view in relationship_app/views.py that displays details for a specific library, listing all books available in that library.
        Utilize Django’s ListView or DetailView to structure this class-based view.

    Configure URL Patterns:
        Edit relationship_app/urls.py to include URL patterns that route to the newly created views. Make sure to link both the function-based and class-based views.

    Create Templates (Optional for Display):
        For a more structured output, using the code below as templates for each view to render the information in HTML format instead of plain text.

Template for Listing Books (list_books.html):

This template will be used by the function-based view to display a list of all books.

<!-- list_books.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>List of Books</title>
</head>
<body>
    <h1>Books Available:</h1>
    <ul>
        {% for book in books %}
        <li>{{ book.title }} by {{ book.author.name }}</li>
        {% endfor %}
    </ul>
</body>
</html>

Template for Displaying Library Details (library_detail.html):

This template will be used by the class-based view to show details of a specific library, including all books available in that library.

<!-- library_detail.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Library Detail</title>
</head>
<body>
    <h1>Library: {{ library.name }}</h1>
    <h2>Books in Library:</h2>
    <ul>
        {% for book in library.books.all %}
        <li>{{ book.title }} by {{ book.author.name }} (Published {{ book.publication_year }})</li>
        {% endfor %}
    </ul>
</body>
</html>

Repo:

    GitHub repository: Alx_DjangoLearnLab
    Directory: django-models

2. Implementing User Authentication in Django
mandatory

Objective: Develop the ability to manage user authentication within a Django application. This task focuses on setting up user login, logout, and registration functionalities using Django’s built-in authentication system.
Task Description:

Enhance your relationship_app by adding user authentication features. Implement views and templates for user login, logout, and registration to demonstrate how Django manages user sessions and permissions.
Steps:

    Setup User Authentication Views:
        Utilize Django’s built-in views and forms for handling user authentication. You will need to create views for user login, logout, and registration.

    Create Templates for Authentication:
        Provide HTML templates for each authentication action (login, logout, and registration). Templates will be provided, allowing you to focus on backend integrations. Below is the recommended templates structure:

relationship_app/

│── templates/

│ ├── relationship_app/

│ │ ├── login.html

│ │ ├── register.html

│ │ ├── logout.html

    Configure URL Patterns:
        Define URL patterns in relationship_app/urls.py to link to the authentication views.

    Test Authentication Functionality:
        Ensure that users can register, log in, and log out.

Provided HTML Templates:

Login Template (login.html):

<!-- login.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Login</title>
    <link rel="stylesheet" href="{% static 'css/styles.css' %}">
</head>
<body>
    <h1>Login</h1>
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Login</button>
    </form>
    <a href="{% url 'register' %}">Register</a>
</body>
</html>

Logout Template (logout.html):

<!-- logout.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Logout</title>
</head>
<body>
    <h1>You have been logged out</h1>
    <a href="{% url 'login' %}">Login again</a>
</body>
</html>

Registration Template (register.html):

<!-- register.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Register</title>
    <link rel="stylesheet" href="{% static 'css/styles.css' %}">
</head>
<body>
    <h1>Register</h1>
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Register</button>
    </form>
</body>
</html>

Repo:

    GitHub repository: Alx_DjangoLearnLab
    Directory: django-models

3. Implement Role-Based Access Control in Django
mandatory

Objective: Implement role-based access control within a Django application to manage different user roles and permissions effectively. You will extend the User model and create views that restrict access based on user roles.
Task Description:

In your Django project, you will extend the Django User model to include user roles and develop views that restrict access based on these roles. Your task is to set up this system by creating a new model for user profiles, defining views with access restrictions, and configuring URL patterns.
Step 1: Extend the User Model with a UserProfile

Create a UserProfile model that includes a role field with predefined roles. This model should be linked to Django’s built-in User model with a one-to-one relationship.

    Fields Required:
        user: OneToOneField linked to Django’s User.
        role: CharField with choices for ‘Admin’, ‘Librarian’, and ‘Member’.
    Automatic Creation: Use Django signals to automatically create a UserProfile when a new user is registered.

Step 2: Set Up Role-Based Views

Create three separate views to manage content access based on user roles:

    Views to Implement:
        An ‘Admin’ view that only users with the ‘Admin’ role can access, the name of the file should be admin_view
        A ‘Librarian’ view accessible only to users identified as ‘Librarians’. The file should be named librarian_view
        A ‘Member’ view for users with the ‘Member’ role, the name of the file should be member_view

    Access Control:
        Utilize the @user_passes_test decorator to check the user’s role before granting access to each view.

Step 3: Configure URL Patterns

Define URL patterns that will route to the newly created role-specific views. Ensure that each URL is correctly linked to its respective view and that the URLs are named for easy reference.

    URLs to Define:
        A URL for the ‘Admin’ view.
        A URL for the ‘Librarian’ view.
        A URL for the ‘Member’ view.

Step 4: Create Role-Based HTML Templates

For each role, create an HTML template to display relevant content when users access their respective views.

Templates to Create:

    admin_view.html for Admin users.
    librarian_view.html for Librarians.
    member_view.html for Members.

Repo:

    GitHub repository: Alx_DjangoLearnLab
    Directory: django-models
    File: models.py, views.py, urls.py

4. Implementing Custom Permissions in Django
mandatory

Objective: Implement custom permissions in your Django application to control access to specific actions such as adding, editing, and deleting book entries based on user roles. This task will guide you through creating these permissions in the model and enforcing them in views.
Task Description:

In the relationship_app of your Django project, extend the existing Book model to include custom permissions. You will then update the views to enforce these permissions, ensuring that only authorized users can perform certain actions.
Step 1: Extend the Book Model with Custom Permissions

Add custom permissions to the Book model to specify who can add, edit, or delete the entries.

    Model Changes Required:
        Inside the Book model, define a nested Meta class.
        Within this Meta class, specify a permissions tuple that includes permissions like can_add_book, can_change_book, and can_delete_book.

Step 2: Update Views to Enforce Permissions

Adjust your views to check if a user has the necessary permissions before allowing them to perform create, update, or delete operations.

    Views to Modify:
        Use Django’s permission_required decorator to secure views that add, edit, or delete books.
        For each view, apply the corresponding permission.

Step 3: Define URL Patterns for Secured Views

Ensure that the secured views are accessible through specific URLs. Set up these URLs in your urls.py file and ensure they are properly named for clarity.

    URLs to Setup:
        Create distinct paths for adding, editing, and deleting books.
        Link each path to its respective view with the appropriate permissions.

Deliverables:

    models.py: Update the Book model to include a Meta class with defined custom permissions.
    views.py: Implement permission checks in the views that handle book creation, modification, and deletion.
    urls.py: Configure and submit the URL patterns that map to the secured views.

Instructions for Each File:

    models.py: In the Book model, add a Meta class defining the custom permissions.
    views.py: For each action (add, edit, delete), use the permission_required decorator from django.contrib.auth.decorators to check the corresponding permission.
    urls.py: Define URL patterns that use the views decorated with permissions.

Repo:

    GitHub repository: Alx_DjangoLearnLab
    Directory: django-models

